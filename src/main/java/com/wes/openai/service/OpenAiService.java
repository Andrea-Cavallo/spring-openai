package com.wes.openai.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.openai.api.OpenAiApi;
import org.springframework.ai.openai.api.OpenAiApi.ChatCompletionRequest;
import org.springframework.ai.openai.api.OpenAiApi.ChatCompletionMessage;
import org.springframework.ai.openai.api.OpenAiApi.ChatCompletionMessage.Role;
import org.springframework.ai.openai.api.OpenAiApi.ChatCompletion;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.web.client.RestClientException;

import java.util.List;
import java.util.Map;

@RequiredArgsConstructor
@Slf4j
@Service
public class OpenAiService implements IOpenAiService {

    private final MeterRegistry meterRegistry;
    private final OpenAiApi openAiApi;
    private final ObjectMapper objectMapper;

    @Value("${spring.ai.openai.chat.options.model}")
    private String model;

    @Value("${spring.ai.openai.chat.options.temperature}")
    private float temperature;

    /**
     * Retrieves the response from OpenAI for a given prompt.
     *
     * @param prompt the prompt for which the response needs to be generated
     * @return the response generated by OpenAI
     * @throws JsonProcessingException if there is an error during JSON processing
     */
    @Cacheable("embeddings")
    @Override
    public String getResponseFromOpenAI(String prompt) throws JsonProcessingException {
        log.info("Generating embedding for prompt: {}", prompt);
        meterRegistry.counter("openai.service.requests").increment();
        try {
            ChatCompletionRequest chatRequest = new ChatCompletionRequest(
                    List.of(new ChatCompletionMessage(prompt, Role.USER)),
                    model,
                    temperature
            );
            ResponseEntity<ChatCompletion> responseEntity = openAiApi.chatCompletionEntity(chatRequest);
            log.info("Successfully generated embedding for prompt: {}", prompt);
            return getContent(responseEntity);
        } catch (RestClientException e) {
            log.error("Error while calling OpenAI API", e);
            throw e;
        } catch (Exception e) {
            log.error("Unexpected error", e);
            throw e;
        }
    }

    /**
     * Retrieves the content from the given {@link ResponseEntity} of type {@link ChatCompletion}.
     *
     * @param responseEntity the ResponseEntity containing the ChatCompletion response
     * @return the content extracted from the ResponseEntity, or an empty string if the content is not available
     * @throws JsonProcessingException if there is an error during JSON processing
     */
    private String getContent(ResponseEntity<ChatCompletion> responseEntity) throws JsonProcessingException {
        ChatCompletion response = responseEntity.getBody();
        if (response != null) {
            // Convert ChatCompletion to JSON string
            String jsonResponse = objectMapper.writeValueAsString(response);
            // Convert JSON string to Map
            Map mapOf = objectMapper.readValue(jsonResponse, Map.class);

            if (mapOf.containsKey("choices")) {
                List<Map<String, Object>> choices = (List<Map<String, Object>>) mapOf.get("choices");
                if (!choices.isEmpty() && choices.get(0).containsKey("message")) {
                    Map<String, Object> message = (Map<String, Object>) choices.get(0).get("message");
                    if (message.containsKey("content")) {
                        return (String) message.get("content");
                    }
                }
            }
        }
        return "";
    }
}

